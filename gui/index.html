<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Orphanage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/gui/style.css">
  <style>
    .torrent-hdr { display:flex; align-items:center; gap:6px; cursor:pointer; margin:6px 0; }
    .toggle-btn { font-weight:bold; width:18px; text-align:center; }
    .torrent-files { margin-left:20px; display:none; }
    .torrent-files.open { display:block; }
    
    /* Checkbox column styling */
    .cell.checkbox {
      width: 30px;
      padding: 8px;
      text-align: center;
    }
    
    .cell.checkbox input[type="checkbox"] {
      margin: 0;
      cursor: pointer;
    }
    
    /* Constrain page width but keep left-aligned */
    .main-layout {
      max-width: 1400px;
      margin-left: 0;
    }
    
    /* Select All checkbox styling */
    .select-all-label {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    
    .select-all-checkbox {
      margin: 0;
      cursor: pointer;
    }
    
    /* Draggable modal styling */
    .draggable-modal {
      position: fixed !important;
      top: 20px;
      left: 20px;
      margin: 0 !important;
      width: calc(100% - 40px) !important;
      max-width: none !important;
      max-height: calc(100vh - 40px) !important;
      transform: none;
    }
    
    /* Responsive draggable modal */
    @media (min-width: 768px) {
      .draggable-modal {
        top: 30px;
        left: 30px;
        width: calc(100% - 60px) !important;
        max-height: calc(100vh - 60px) !important;
      }
    }
    
    @media (min-width: 1024px) {
      .draggable-modal {
        top: 40px;
        left: 40px;
        width: calc(100% - 80px) !important;
        max-height: calc(100vh - 80px) !important;
      }
    }
    
    @media (min-width: 1400px) {
      .draggable-modal {
        top: 50px;
        left: 50px;
        width: calc(100% - 100px) !important;
        max-height: calc(100vh - 100px) !important;
      }
    }
    
    .draggable-header {
      user-select: none;
    }
    
    /* Prevent all visual flash during page load */
    body:not(.loaded) {
      visibility: hidden;
    }
    
    body.loaded {
      visibility: visible;
    }
    
    /* Hide top bar until loaded to prevent shift */
    body:not(.loaded) .appbar {
      visibility: hidden;
    }
    
  </style>
</head>
<body>
  <header class="appbar">
    <!-- First Row: Logo + Title + Action Buttons -->
    <div class="appbar-top">
      <div class="appbar-left">
        <div class="logo">üßπ</div>
        <div class="title-wrap">
          <h1 class="title">Orphanage</h1>
        </div>
      </div>
      <div class="appbar-right">
        <button id="exportBtn" class="btn btn-ghost" title="Export" onclick="openExport()" hidden>Export</button>
        <button class="btn btn-ghost" title="Help" onclick="openHelp()">?</button>
        <button class="btn btn-ghost" title="Settings" onclick="openConfigModal()">‚öôÔ∏è</button>
        <button class="btn btn-ghost" id="themeBtn" title="Toggle theme" onclick="toggleTheme()">üåì</button>
        <button id="scanBtn" class="btn btn-primary" onclick="toggleScan()">
          <span class="spinner" id="scanSpin" hidden></span>
          <span id="scanLabel">Run Scan</span>
        </button>
        <button id="deleteSelectedBtn" class="btn btn-danger" onclick="deleteSelectedFiles()" style="display: none;">
          Delete Selected (<span id="selectedCount">0</span>)
        </button>
      </div>
    </div>
    
  </header>

  <main class="main-layout">
    <!-- Left Sidebar Navigation -->
    <aside id="sidebar" class="sidebar" hidden>
      <!-- Column: Deluge -->
      <div id="colDeluge" class="nav-section" hidden>
        <div class="nav-title">Deluge</div>
        <div class="nav-links">
          <a href="#deluge-orphans" class="nav-link" data-key="deluge-orphans" onclick="loadSection('deluge-orphans')">
            Orphans
          </a>
          <a href="#deluge-runaways" class="nav-link" data-key="deluge-runaways" onclick="loadSection('deluge-runaways')">
            Runaways
          </a>
          <a href="#deluge-reportcards" class="nav-link" data-key="deluge-reportcards" onclick="loadSection('deluge-reportcards')">
            Report Cards
          </a>
        </div>
      </div>

      <!-- Column: qBittorrent -->
      <div id="colQbit" class="nav-section" hidden>
        <div class="nav-title">qBittorrent</div>
        <div class="nav-links">
          <a href="#qbit-orphans" class="nav-link" data-key="qbit-orphans" onclick="loadSection('qbit-orphans')">
            Orphans
          </a>
          <a href="#qbit-runaways" class="nav-link" data-key="qbit-runaways" onclick="loadSection('qbit-runaways')">
            Runaways
          </a>
          <a href="#qbit-reportcards" class="nav-link" data-key="qbit-reportcards" onclick="loadSection('qbit-reportcards')">
            Report Cards
          </a>
        </div>
      </div>
    </aside>

    <!-- Main Content Area -->
    <div class="content-area">
      <!-- Status Bar -->
      <div class="status-bar">
        <div id="status" class="status-text">No results yet. Click Run Scan.</div>
      </div>

      <!-- Progress Bar -->
      <div id="progress" class="progress" hidden>
        <div class="progress-track"><div id="progressBar" class="progress-bar" style="width:0%"></div></div>
        <div class="progress-info">
          <div id="phaseLabel" class="progress-label">Starting‚Ä¶</div>
          <div id="phaseCounts" class="progress-counts"></div>
        </div>
      </div>

      <!-- Section body -->
      <section id="section-body" class="panel">
      </section>
    </div>
  </main>

  <footer class="footer">
  </footer>

  <!-- Help Modal -->
  <div id="helpModal" class="modal" hidden>
    <div class="modal-card">
      <div class="modal-header">
        <h3>What do these mean?</h3>
        <button class="btn btn-ghost btn-sm" onclick="closeHelp()">‚úï</button>
      </div>
      <div class="modal-body">
        <p><strong>Orphan</strong> ‚Äî <em>on disk, not in client</em></p>
        <ul class="help-list">
          <li><b>What it is:</b> A file found in your torrent folders that your client doesn‚Äôt list.</li>
          <li><b>Causes:</b> manual moves, torrent removed from client, mis-routed category, imports gone wrong.</li>
          <li><b>Detection:</b> Walk <code>Deluge_Torrent_Folder</code> / <code>Qbit_Torrent_Folder</code> and compare to client‚Äôs file list.</li>
          <li><b>Fix:</b> delete/move, re-add .torrent (skip re-download), or fix category/watch.</li>
        </ul>

        <p><strong>Runaway</strong> ‚Äî <em>in client, missing on disk</em></p>
        <ul class="help-list">
          <li><b>What it is:</b> Client says a file exists, but the OS can‚Äôt find it at the mapped path.</li>
          <li><b>Causes:</b> deleted/moved files, wrong container bind, NAS drop, wrong save path.</li>
          <li><b>Detection:</b> Map client paths via <code>Deluge_Path_In‚ÜíOut</code> / <code>Qbit_Path_In‚ÜíOut</code> and check filesystem.</li>
          <li><b>Fix:</b> correct mapping, restore/move files, or force recheck.</li>
        </ul>

        <p><strong>Report Card</strong> ‚Äî <em>tracker errors</em></p>
        <ul class="help-list">
          <li><b>What it is:</b> Announce/HTTP errors or statuses like ‚Äúerror‚Ä¶‚Äù.</li>
          <li><b>Examples:</b> <code>unregistered torrent</code>, <code>timed out</code>, <code>connection refused</code>.</li>
          <li><b>Detection:</b> Deluge <code>tracker_status</code> starts with ‚Äúerror‚Äù; qBit: any tracker where <code>status == 4</code> or <code>msg</code> contains ‚Äúerror‚Äù.</li>
          <li><b>Fix:</b> re-download .torrent, re-announce, check VPN/port forward/ratio rules.</li>
        </ul>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" onclick="closeHelp()">Got it</button>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div id="exportModal" class="modal" hidden>
    <div class="modal-card">
      <div class="modal-header">
        <h3>Export to results.json</h3>
        <button class="btn btn-ghost btn-sm" onclick="closeExport()">‚úï</button>
      </div>
      <div class="modal-body">
        <div id="exportOptions" class="export-grid"></div>
      </div>
      <div class="modal-footer">
        <button class="btn" onclick="closeExport()">Cancel</button>
        <button class="btn btn-primary" onclick="doExport()">Create File</button>
      </div>
    </div>
  </div>

  <!-- File Relationships Modal -->
  <div id="relationshipsModal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modalTitle">File Relationships</h2>
        <span class="modal-close" onclick="closeRelationshipsModal()">&times;</span>
      </div>
      <div class="modal-body">
        <div id="modalLoading" style="display: none;">
          <p>üîç Searching for relationships...</p>
        </div>
        <div id="modalResults"></div>
      </div>
    </div>
  </div>

  <!-- Bulk Delete Confirmation Modal -->
  <div id="bulkDeleteModal" class="modal" style="display: none;">
    <div class="modal-content delete-modal-content draggable-modal" style="max-width: 800px; margin: 10% auto; position: relative; max-height: 80vh;">
      <div class="modal-header draggable-header" style="cursor: move;">
        <h2>‚ö†Ô∏è Confirm Delete</h2>
        <span class="modal-close" onclick="closeBulkDeleteModal()">&times;</span>
      </div>
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div class="delete-warning">
          <p id="deleteMessage">This will <strong>permanently delete</strong> <span id="deleteItemCount">0</span> selected files from your filesystem.</p>
          <p class="warning-text">‚ö†Ô∏è This action cannot be undone!</p>
        </div>
        
        <!-- Folder deletion section -->
        <div id="folderDeleteSection" style="display: none; margin: 20px 0; padding: 15px; background: var(--bg-elev); border-radius: 6px; border-left: 4px solid var(--primary);">
          <h4 style="margin: 0 0 10px 0; color: var(--primary);">üìÅ Folder Deletion Available</h4>
          <p id="folderDeleteMessage" style="margin: 0 0 10px 0; font-size: 14px;"></p>
          <div style="font-family: monospace; font-size: 13px; background: var(--bg); padding: 8px; border-radius: 4px; border: 1px solid var(--border);">
            <strong id="folderPath"></strong>
          </div>
        </div>
        
        <!-- File list section -->
        <div style="margin: 20px 0;">
          <h4 style="margin: 0 0 10px 0;">Files to be deleted:</h4>
          <div id="filesList" style="max-height: 300px; overflow-y: auto; background: var(--bg-elev); border-radius: 4px; padding: 10px; border: 1px solid var(--border);">
            <!-- File list will be populated here -->
          </div>
        </div>
      </div>
      <div class="modal-footer" style="display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center;">
          <label id="deleteFolderCheckbox" style="display: none; align-items: center; margin-right: 15px; cursor: pointer;">
            <input type="checkbox" id="deleteFolderOption" style="margin-right: 8px;">
            <span id="deleteFolderLabel">Delete Folder</span>
          </label>
        </div>
        <div>
          <button class="btn" onclick="closeBulkDeleteModal()">Cancel</button>
          <button class="btn btn-danger" id="confirmDeleteBtn" onclick="confirmBulkDelete()">Delete Files Permanently</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Config Settings Modal -->
  <div id="configModal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title-section">
          <h2>Configuration Settings</h2>
          <span class="help-text" onclick="toggleHelp()" title="Click for help">?</span>
        </div>
        <div class="modal-header-center">
          <label class="header-form-group">
            <span>Log Level:</span>
            <select id="logLevel">
              <option value="DEBUG">DEBUG</option>
              <option value="INFO">INFO</option>
              <option value="WARNING">WARNING</option>
              <option value="ERROR">ERROR</option>
              <option value="CRITICAL">CRITICAL</option>
            </select>
          </label>
        </div>
        <div class="modal-header-actions">
          <button class="btn" onclick="closeConfigModal()">Cancel</button>
          <button class="btn btn-primary" onclick="saveConfig()">Save Changes</button>
        </div>
      </div>
      <div class="modal-body">
        <div id="helpSection" class="help-section" style="display: none;">
          <p><strong>Configuration Help:</strong></p>
          <p><strong>URLs:</strong> Web interface addresses for your torrent clients (e.g., http://192.168.1.100:8112)</p>
          <p><strong>Credentials:</strong> Login details for accessing the web interfaces</p>
          <p><strong>Torrent Folders:</strong> Directory paths where torrent data is stored</p>
          <p><strong>Path In/Out:</strong> Path Out should match your torrent client actual host system path, Path In should match your torrent client container path (ex. /mnt/user/data:/data)</p>
          <p><strong>Log Level:</strong> Controls verbosity of logging (DEBUG = most detailed, ERROR = only errors)</p>
        </div>
        
        <form id="configForm">
          <div class="config-compact-grid">
            <!-- Row 1: Enable checkboxes -->
            <div class="config-row">
              <label class="checkbox-header">
                <input type="checkbox" id="enableDeluge" /> <strong>Enable Deluge</strong>
              </label>
              <label class="checkbox-header">
                <input type="checkbox" id="enableQbit" /> <strong>Enable qBittorrent</strong>
              </label>
            </div>
            
            <!-- Row 2: Configuration headers -->
            <div class="config-row">
              <h3>Deluge Configuration</h3>
              <h3>qBittorrent Configuration</h3>
            </div>
            
            <!-- Row 3: URLs -->
            <div class="config-row">
              <label class="form-group-compact">
                <span>URL:</span>
                <input type="text" id="delugeUrl" placeholder="http://192.168.1.100:8112" />
              </label>
              <label class="form-group-compact">
                <span>URL:</span>
                <input type="text" id="qbitUrl" placeholder="http://192.168.1.100:8090" />
              </label>
            </div>
            
            <!-- Row 4: Password vs Username/Password -->
            <div class="config-row">
              <label class="form-group-compact">
                <span>Password:</span>
                <input type="password" id="delugePass" placeholder="admin" />
              </label>
              <div class="credentials-row">
                <label class="cred-group">
                  <span>Username:</span>
                  <input type="text" id="qbitUser" placeholder="admin" />
                </label>
                <label class="cred-group">
                  <span>Password:</span>
                  <input type="password" id="qbitPass" placeholder="adminadmin" />
                </label>
              </div>
            </div>
            
            <!-- Row 5: Torrent Folders -->
            <div class="config-row">
              <label class="form-group-compact">
                <span>Torrent Folder:</span>
                <input type="text" id="delugeTorrentFolder" placeholder="/data/torrents/deluge" />
              </label>
              <label class="form-group-compact">
                <span>Torrent Folder:</span>
                <input type="text" id="qbitTorrentFolder" placeholder="/data/torrents/qbit" />
              </label>
            </div>
            
            <!-- Row 6: Path Out (Host) -->
            <div class="config-row">
              <label class="form-group-compact">
                <span>Path Out (Host):</span>
                <input type="text" id="delugePathOut" placeholder="/mnt/user/data" />
              </label>
              <label class="form-group-compact">
                <span>Path Out (Host):</span>
                <input type="text" id="qbitPathOut" placeholder="/mnt/user/data" />
              </label>
            </div>
            
            <!-- Row 7: Path In (Container) -->
            <div class="config-row">
              <label class="form-group-compact">
                <span>Path In (Container):</span>
                <input type="text" id="delugePathIn" placeholder="/data" />
              </label>
              <label class="form-group-compact">
                <span>Path In (Container):</span>
                <input type="text" id="qbitPathIn" placeholder="/data" />
              </label>
            </div>
          </div>

        </form>
      </div>
    </div>
  </div>

  <style>
    .modal {
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    .modal-content {
      background-color: var(--bg);
      margin: 20px;
      padding: 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      width: calc(100% - 40px);
      max-width: none;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }
    
    /* Responsive width breakpoints */
    @media (min-width: 768px) {
      .modal-content {
        width: calc(100% - 60px);
        margin: 30px;
        max-height: calc(100vh - 60px);
      }
    }
    
    @media (min-width: 1024px) {
      .modal-content {
        width: calc(100% - 80px);
        margin: 40px;
        max-height: calc(100vh - 80px);
      }
    }
    
    @media (min-width: 1400px) {
      .modal-content {
        width: calc(100% - 100px);
        margin: 50px;
        max-height: calc(100vh - 100px);
      }
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }
    
    .modal-close {
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      color: var(--text);
    }
    
    .modal-close:hover {
      color: var(--primary);
    }
    
    .modal-body {
      padding: 20px;
    }
    
    .relationship-item {
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 15px;
      background: var(--bg-secondary);
    }
    
    .delete-modal-content {
      max-width: 500px;
      margin: 10% auto;
    }
    
    .delete-warning {
      padding: 20px;
      text-align: center;
    }
    
    .delete-warning p {
      margin: 12px 0;
      color: var(--text);
    }
    
    .file-path-display {
      background: var(--bg-secondary);
      border: 2px solid #dc3545;
      border-radius: 4px;
      padding: 12px;
      margin: 15px 0;
      word-break: break-all;
    }
    
    .file-path-display code {
      font-family: monospace;
      font-size: 13px;
      color: var(--text);
    }
    
    .warning-text {
      color: #721c24 !important;
      font-weight: 500;
    }
    
    .modal-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .delete-result-success {
      color: #155724;
      background: #d4edda;
      border: 1px solid #c3e6cb;
      padding: 15px;
      border-radius: 6px;
      text-align: center;
    }
    
    .delete-result-error {
      color: #721c24;
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      padding: 15px;
      border-radius: 6px;
      text-align: center;
    }
    
    .btn-danger {
      background-color: #dc3545;
      color: white;
      border: 2px solid #dc3545;
      font-weight: 600;
    }
    
    .btn-danger:hover {
      background-color: #c82333;
      border-color: #bd2130;
      transform: scale(1.02);
    }
    
    .btn-sm {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .relationship-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .client-badge {
      background: var(--primary);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      text-transform: uppercase;
    }
    
    .file-path {
      font-family: monospace;
      background: var(--bg);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
      word-break: break-all;
    }
    
    .clickable-filename {
      cursor: pointer;
      color: var(--primary);
      text-decoration: underline;
    }
    
    .clickable-filename:hover {
      background-color: var(--bg-secondary);
    }
    
    .modal-title-section {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .modal-header-center {
      display: flex;
      align-items: center;
    }
    
    .modal-header-actions {
      display: flex;
      gap: 10px;
    }
    
    .header-form-group {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    
    .header-form-group span {
      font-weight: 500;
      color: var(--text);
    }
    
    .header-form-group select {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }
    
    .help-text {
      background: var(--primary);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }
    
    .help-text:hover {
      opacity: 0.8;
    }
    
    .help-section {
      background: var(--bg-secondary);
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      border-left: 4px solid var(--primary);
    }
    
    .help-section p {
      margin: 5px 0;
      font-size: 14px;
    }
    
    .config-compact-grid {
      margin-bottom: 15px;
    }
    
    .config-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 10px;
      align-items: center;
    }
    
    .config-row h3 {
      margin: 0;
      color: var(--primary);
      font-size: 16px;
    }
    
    .checkbox-header {
      margin-bottom: 10px !important;
    }
    
    .checkbox-header input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .form-group-compact {
      display: block;
      margin: 0;
    }
    
    .form-group-compact span {
      display: inline-block;
      width: 140px;
      font-weight: 500;
      vertical-align: top;
      padding-top: 8px;
    }
    
    .form-group-compact input[type="text"],
    .form-group-compact input[type="password"] {
      width: 200px;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }
    
    .credentials-row {
      display: flex;
      gap: 10px;
    }
    
    .cred-group {
      display: block;
      flex: 1;
    }
    
    .cred-group span {
      display: inline-block;
      width: 70px;
      font-weight: 500;
      vertical-align: top;
      padding-top: 8px;
      font-size: 14px;
    }
    
    .cred-group input[type="text"],
    .cred-group input[type="password"] {
      width: 90px;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }
    
    
    .form-group {
      display: block;
      margin-bottom: 12px;
    }
    
    .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 12px;
    }
    
    .form-group-half {
      display: block;
      flex: 1;
    }
    
    .form-group-half span {
      display: inline-block;
      width: 80px;
      font-weight: 500;
      vertical-align: top;
      padding-top: 8px;
    }
    
    .form-group-half input[type="text"],
    .form-group-half input[type="password"] {
      width: 120px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
    }
    
    .form-group span {
      display: inline-block;
      width: 200px;
      font-weight: 500;
      vertical-align: top;
      padding-top: 8px;
    }
    
    .form-group input[type="text"],
    .form-group input[type="password"],
    .form-group select {
      width: 300px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
    }
    
    .form-group input[type="checkbox"] {
      margin-right: 8px;
      vertical-align: middle;
    }
    
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }
  </style>

  <script>
    (function initTheme(){
      const saved = localStorage.getItem("orphanage-theme");
      document.documentElement.dataset.theme = (saved === "light") ? "light" : "dark";
    })();
    function toggleTheme(){
      const root = document.documentElement;
      const now = root.dataset.theme === "dark" ? "light" : "dark";
      root.dataset.theme = now;
      localStorage.setItem("orphanage-theme", now);
    }

    let currentKey = null;
    let currentPayload = null;
    let currentPage = 1;
    const pageSize = 500;
    let torrentPage = 1;
    const torrentsPerPage = 50;
    let cfg = { ENABLE_DELUGE: false, ENABLE_QBIT: false };
    let pollTimer = null;
    let lastRunning = null;
    let highlightsVisible = false;
    let scanInProgress = false;

    function byId(id){ return document.getElementById(id); }
    function show(el, v){ if (el) el.hidden = !v; }
    function escapeHtml(s){return (s||"").replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;"," >":"&gt;","\"":"&quot;","'":"&#39;"}[m]));}
    async function api(path, opts={}) { const res = await fetch(path, opts); if (!res.ok) throw new Error(await res.text()); return res.json(); }

    function paginate(list){
      const start = (currentPage - 1) * pageSize;
      return list.slice(start, start + pageSize);
    }
    function renderPaginationControls(root, listLength){
      if (listLength <= pageSize) return;
      const pages = Math.ceil(listLength / pageSize);
      let controls = `<div class="pagination">`;
      for (let i=1; i<=pages; i++){
        controls += `<button class="btn btn-sm ${i===currentPage?"btn-primary":""}" onclick="goToPage(${i})">${i}</button>`;
      }
      controls += `</div>`;
      root.insertAdjacentHTML("beforeend", controls);
    }
    function goToPage(n){
      currentPage = n;
      renderCurrent();
    }

    function renderTorrentPagination(allTorrents) {
      const totalPages = Math.ceil(allTorrents.length / torrentsPerPage);
      if (totalPages <= 1) return "";
      let controls = `<div class="pagination">`;
      for (let i=1; i<=totalPages; i++) {
        controls += `<button class="btn btn-sm ${i===torrentPage?"btn-primary":""}" onclick="changeTorrentPage(${i})">${i}</button>`;
      }
      controls += `</div>`;
      return controls;
    }
    function changeTorrentPage(n) {
      torrentPage = n;
      renderCurrent();
    }

    function renderRunaways(groups, torrentInfo = {}){
      const keys = Object.keys(groups).sort();
      const start = (torrentPage-1) * torrentsPerPage;
      const subset = keys.slice(start, start+torrentsPerPage);
      let html = "";
      
      for (const torrent of subset) {
          const files = groups[torrent] || [];
          const rows = files.map(r => `
              <tr class="row">
                  <td class="cell path">${escapeHtml(r)}</td>
                  <td class="cell tools"></td>
              </tr>`).join('');
          
          const isOpen = expandedTorrents.has(torrent);
          const info = torrentInfo[torrent] || {};
          
          // Create enhanced header with torrent info: Client ‚Üí Label ‚Üí Tracker ‚Üí Torrent Name
          const client = (info.client || 'unknown').toUpperCase();
          const label = info.label || 'None';
          const tracker = info.tracker || 'Unknown';
          
          html += `
              <div class="torrent-hdr runaway-hdr" onclick="toggleTorrent('${escapeHtml(torrent)}')">
                  <span id="toggle-${escapeHtml(torrent)}" class="toggle-btn">${isOpen ? "‚àí" : "+"}</span>
                  <div class="torrent-info">
                    <div class="torrent-name">${escapeHtml(torrent)}</div>
                    <div class="torrent-meta">
                      <span class="client-badge">${client}</span> ‚Üí 
                      <span class="label-badge">${escapeHtml(label)}</span> ‚Üí 
                      <span class="tracker-badge">${tracker}</span>
                    </div>
                  </div>
                  <span class="badge">Missing Files <span class="pill">${files.length}</span></span>
              </div>
              <div id="files-${escapeHtml(torrent)}" class="torrent-files ${isOpen ? "open" : ""}">
                  <div class="table-wrap"><table class="grid"><tbody>${rows}</tbody></table></div>
              </div>`;
      }
      html += renderTorrentPagination(keys);
      return html;
    }

    let expandedTorrents = new Set();
    let expandedGroups = new Set();

    function toggleTorrent(tName){
      const filesDiv = document.getElementById(`files-${tName}`);
      const toggle = document.getElementById(`toggle-${tName}`);
      if (!filesDiv) return;
      const open = filesDiv.classList.toggle("open");
      if (open) {
        expandedTorrents.add(tName);
      } else {
        expandedTorrents.delete(tName);
      }
      toggle.textContent = open ? "‚àí" : "+";
    }

    async function initConfig(){
      try { cfg = await api('/api/config'); } catch { cfg = { ENABLE_DELUGE:true, ENABLE_QBIT:true }; }
      const grid = byId('navGrid');
      const cd = byId('colDeluge'), cq = byId('colQbit');
      const sidebar = byId('sidebar');
      show(cd, !!cfg.ENABLE_DELUGE);
      show(cq, !!cfg.ENABLE_QBIT);
      show(sidebar, !!(cfg.ENABLE_DELUGE || cfg.ENABLE_QBIT));
      show(grid, !!(cfg.ENABLE_DELUGE || cfg.ENABLE_QBIT));

      const exp = byId('exportOptions');
      const rows = [];
      if (cfg.ENABLE_DELUGE) {
        rows.push(`
          <div class="export-group">
            <div class="export-title">Deluge</div>
            <label><input type="checkbox" value="deluge-orphans" checked> Orphans</label>
            <label><input type="checkbox" value="deluge-runaways" checked> Runaways</label>
            <label><input type="checkbox" value="deluge-reportcards" checked> Report Cards</label>
          </div>`);
      }
      if (cfg.ENABLE_QBIT) {
        rows.push(`
          <div class="export-group">
            <div class="export-title">qBittorrent</div>
            <label><input type="checkbox" value="qbit-orphans" checked> Orphans</label>
            <label><input type="checkbox" value="qbit-runaways" checked> Runaways</label>
            <label><input type="checkbox" value="qbit-reportcards" checked> Report Cards</label>
          </div>`);
      }
      exp.innerHTML = rows.join('') || '<div class="empty">No clients enabled.</div>';
    }

    function openHelp(){ show(byId('helpModal'), true); }
    function closeHelp(){ show(byId('helpModal'), false); }

    function openExport(){ show(byId('exportModal'), true); }
    function closeExport(){ show(byId('exportModal'), false); }
    async function doExport(){
      const checks = Array.from(byId('exportOptions').querySelectorAll('input[type=checkbox]:checked')).map(i=>i.value);
      if (checks.length === 0) { closeExport(); return; }
      const params = new URLSearchParams({ keys: checks.join(',') });
      const res = await fetch('/api/export?' + params.toString());
      if (!res.ok) { closeExport(); return; }
      const blob = await res.blob();
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'results.json';
      a.click();
      URL.revokeObjectURL(a.href);
      closeExport();
    }

    window.onclick = function(e) {
      const m1 = byId('exportModal'), m2 = byId('helpModal');
      if (e.target === m1) closeExport();
      if (e.target === m2) closeHelp();
    };

    async function toggleScan(){
      const btn = byId('scanBtn'),
            spin = byId('scanSpin'),
            label = byId('scanLabel'),
            status = byId('status');

      const st = await api('/api/status');

      if (st.running) {
        status.style.display = "block";
        status.textContent = "Stopping scan‚Ä¶";
        label.textContent = "Stopping‚Ä¶";

        btn.disabled = true; show(spin, true);
        try { await fetch('/api/scan/stop', {method:'POST'}); } catch(e){}
        btn.disabled = false; show(spin, false);
        pollStatusOnce(true);

      } else {
        clearHighlights();
        highlightsVisible = false;
        status.style.display = "block";
        status.textContent = "Starting scan‚Ä¶";
        label.textContent = "Starting‚Ä¶";

        btn.disabled = true; show(spin, true);
        try { await fetch('/api/scan/start', {method:'POST'}); } catch(e){}
        btn.disabled = false; show(spin, false);
        pollStatusOnce(true);
      }
    }

    function scheduleNext(ms){ if (pollTimer) clearTimeout(pollTimer); pollTimer = setTimeout(pollStatusOnce, ms); }

    function clearHighlights(){
      document.querySelectorAll('.nav-link[data-key]').forEach(link=>{
        link.classList.remove('highlight');
        const pill = link.querySelector('.count-pill');
        if (pill) pill.remove();
      });
    }

    async function refreshReportCards() {
      // Force refresh report cards data by clearing backend cache and updating highlights
      try {
        // Call a backend endpoint to refresh report cards (if available)
        // For now, just update the highlights which will fetch fresh data
        const reportKeys = [];
        if (cfg.ENABLE_DELUGE) reportKeys.push("deluge-reportcards");
        if (cfg.ENABLE_QBIT) reportKeys.push("qbit-reportcards");
        
        // Update highlights for report cards specifically
        const payloads = await Promise.all(
          reportKeys.map(k => fetch(`/api/section?key=${encodeURIComponent(k)}&refresh=true`)
            .then(r => r.ok ? r.json() : null).catch(()=>null))
        );

        for (let i=0; i<reportKeys.length; i++){
          const key = reportKeys[i];
          const data = payloads[i];
          const link = document.querySelector(`.nav-link[data-key="${key}"]`);
          if (!link) continue;

          let pill = link.querySelector('.count-pill');
          if (!pill) {
            pill = document.createElement('span');
            pill.className = 'count-pill';
            link.appendChild(pill);
          }

          let count = 0;
          if (data && key.endsWith('reportcards')) {
            count = data.count || 0;
          }

          if (count > 0) {
            link.classList.add('highlight');
            pill.textContent = String(count);
            pill.hidden = false;
          } else {
            link.classList.remove('highlight');
            pill.remove();
          }
        }
      } catch (error) {
        console.log('Failed to refresh report cards:', error);
      }
    }

    async function updateHighlightsAfterScan(){
      const keys = [];
      if (cfg.ENABLE_DELUGE) keys.push("deluge-orphans","deluge-runaways","deluge-reportcards");
      if (cfg.ENABLE_QBIT)   keys.push("qbit-orphans","qbit-runaways","qbit-reportcards");

      const payloads = await Promise.all(
        keys.map(k => fetch(`/api/section?key=${encodeURIComponent(k)}`)
          .then(r => r.ok ? r.json() : null).catch(()=>null))
      );

      let any = false;
      for (let i=0; i<keys.length; i++){
        const key = keys[i], data = payloads[i];
        const link = document.querySelector(`.nav-link[data-key="${key}"]`);
        if (!link) continue;

        let pill = link.querySelector('.count-pill');
        if (!pill) {
          pill = document.createElement('span');
          pill.className = 'count-pill';
          link.appendChild(pill);
        }

        let count = 0;
        if (data) {
          if (key.endsWith('orphans')) {
            const c = data.counts || {};
            count = (c.dirs || 0) + (c.files || 0);
          } else if (key.endsWith('runaways')) {
            count = data.count || 0;
          } else if (key.endsWith('reportcards')) {
            count = data.count || 0;
          }
        }

        if (count > 0) {
          link.classList.add('highlight');
          pill.textContent = String(count);
          pill.hidden = false;
          any = true;
        } else {
          link.classList.remove('highlight');
          pill.remove();
        }
      }
      highlightsVisible = any;
    }

    async function pollStatusOnce(immediate=false){
      try {
        const st = await api('/api/status');
        const status = byId('status');
        const btn = byId('scanBtn'), label = byId('scanLabel'), spin = byId('scanSpin');
        const progWrap = byId('progress');
        const bar = byId('progressBar');
        const pLabel = byId('phaseLabel');
        const pCounts = byId('phaseCounts');

        if (st.running) {
          if (lastRunning === false && highlightsVisible) {
            clearHighlights();
            highlightsVisible = false;
          }
          
          // Clear section content when scan starts
          if (scanInProgress === false) {
            scanInProgress = true;
            // Trigger re-render to show scan in progress state
            renderCurrent();
          }

          let percent = (st.progress && typeof st.progress.percent === 'number') ? st.progress.percent : 0;
          let labelText = (st.progress && st.progress.label) ? st.progress.label : "Scanning‚Ä¶";
          let phase = (st.progress && st.progress.phase) ? st.progress.phase : 0;
          let total = (st.progress && st.progress.total) ? st.progress.total : 0;

          status.textContent = "Scanning in progress...";
          pLabel.textContent = labelText;
          pCounts.textContent = (phase && total) ? `Phase ${phase} of ${total}` : "";
          bar.style.width = `${percent}%`;
          show(progWrap, true);

          label.textContent = "Stop Scan";
          btn.classList.add('danger');

          lastRunning = true;
          scheduleNext(immediate ? 0 : 1000);
        } else {
          // Reset scan status when scan completes
          if (scanInProgress === true) {
            scanInProgress = false;
          }
          
          if (st.error) status.textContent = `Error: ${st.error}`;
          else if (st.timestamp) status.textContent = `Last scan: ${st.timestamp}`;
          else if (st.cached_timestamp) status.textContent = `Last cached scan data: ${st.cached_timestamp}`;
          else status.textContent = "No results yet. Click Run Scan.";
          label.textContent = "Run Scan";
          btn.classList.remove('danger');
          show(spin, false);
          show(byId('progress'), false);

          if (lastRunning === true) {
            await updateHighlightsAfterScan();
            // Show export button after scan completes
            show(byId('exportBtn'), true);
            
            // Refresh current section if one is active
            if (currentKey) {
              await loadSection(currentKey, true);
            }
          }
          if (lastRunning === null) {
            // Always try to show cached data on startup if available
            if (st.cached_timestamp) {
              await updateHighlightsAfterScan();
              show(byId('exportBtn'), true);
            } else {
              // Still try to load counts from API even if no timestamp
              try {
                await updateHighlightsAfterScan();
                show(byId('exportBtn'), true);
              } catch {
                clearHighlights();
                highlightsVisible = false;
              }
            }
          }
          lastRunning = false;

          scheduleNext(immediate ? 0 : 3500);
        }
      } catch {
        scheduleNext(5000);
      }
    }

    async function loadSection(key, silent=false){
      currentKey = key;
      
      // Hide delete button when switching sections since checkboxes are no longer valid
      const deleteBtn = byId('deleteSelectedBtn');
      if (deleteBtn) deleteBtn.style.display = 'none';
      
      // Update URL hash and active nav link
      if (!silent) {
        window.location.hash = key;
        document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
        const activeLink = document.querySelector(`[data-key="${key}"]`);
        if (activeLink) activeLink.classList.add('active');
      }
      
      // Start a loading timeout to avoid flashing for quick loads
      let loadingTimeout = null;
      if (!silent) {
        loadingTimeout = setTimeout(() => {
          byId('section-body').innerHTML = `<div class="empty">Loading <code>${escapeHtml(key)}</code>‚Ä¶</div>`;
        }, 150); // Show loading message only after 150ms
      }
      
      try {
        const data = await api(`/api/section?key=${encodeURIComponent(key)}`);
        // Clear the loading timeout if data loads quickly
        if (loadingTimeout) clearTimeout(loadingTimeout);
        currentPayload = data;
        torrentPage = 1;
        renderCurrent();
      } catch {
        // Clear the loading timeout and show error
        if (loadingTimeout) clearTimeout(loadingTimeout);
        byId('section-body').innerHTML = `<div class="empty">No data for <code>${escapeHtml(key)}</code> ‚Äî run a scan first.</div>`;
      }
    }


    function rowsToTable(title, rows, clickableType = 'filename', showCheckboxes = false){
      const hdr = `<div class="section-hdr"><h3>${title}</h3><span class="badge">Total <span class="pill">${rows.length}</span></span></div>`;
      if (!rows.length) return hdr + `<div class="empty">None</div>`;
      const body = rows.map(r => {
        const filename = clickableType === 'torrent' ? r.split(' | ')[0] : r.split('/').pop();
        
        // Always use file-checkbox for rowsToTable (used for orphans/runaways)
        // Report cards use renderReportCardsTable which has its own torrent-checkbox logic
        let checkboxValue = r;
        let checkboxClass = 'file-checkbox';
        
        const checkboxCell = showCheckboxes ? 
          `<td class="cell checkbox"><input type="checkbox" class="${checkboxClass}" data-filepath="${escapeHtml(checkboxValue)}" onchange="updateDeleteButtonState()"></td>` : '';
        
        return `
          <tr class="row">
            ${checkboxCell}
            <td class="cell path">
              ${clickableType === 'none' ? 
                `<span>${escapeHtml(r)}</span>` :
                `<span class="clickable-filename" data-filepath="${escapeHtml(r)}" data-type="${clickableType}" title="Click to see relationships">
                  ${escapeHtml(r)}
                </span>`
              }
            </td>
            <td class="cell tools"></td>
          </tr>`;
      }).join('');
      return hdr + `<div class="table-wrap"><table class="grid"><tbody>${body}</tbody></table></div>`;
    }

    function renderReportCardsTable(errorRows) {
      if (!errorRows.length) return `<div class="empty">No torrents</div>`;
      
      const header = `
        <div class="table-wrap">
          <table class="grid">
            <thead>
              <tr>
                <th class="cell checkbox"></th>
                <th class="cell">Client</th>
                <th class="cell">Category/Label</th>
                <th class="cell">Torrent Name</th>
                <th class="cell">Torrent Folder</th>
              </tr>
            </thead>
            <tbody>`;
      
      const body = errorRows.map(row => {
        // Parse both old and new formats:
        // Old: client|torrent_id|torrent_name|category|tags|error_message
        // New: client|torrent_id|torrent_name|category|tags|error_message|save_path
        const parts = row.split('|');
        if (parts.length < 6) return '';
        
        const [client, torrentId, torrentName, category, tags, errorMessage] = parts;
        const savePath = parts.length >= 7 ? parts[6] : '';
        
        const clientDisplay = client.toUpperCase();
        const categoryDisplay = category || 'None';
        
        // Extract last 3 folders from save_path if available
        let folderDisplay = 'Unknown';
        if (savePath) {
          const pathParts = savePath.replace(/\\/g, '/').split('/').filter(p => p);
          if (pathParts.length >= 3) {
            folderDisplay = '/' + pathParts.slice(-3).join('/');
          } else if (pathParts.length > 0) {
            folderDisplay = '/' + pathParts.join('/');
          } else {
            folderDisplay = savePath || 'Unknown';
          }
        }
        
        return `
          <tr class="row">
            <td class="cell checkbox">
              <input type="checkbox" class="torrent-checkbox" data-torrent="${escapeHtml(row)}" onchange="updateDeleteButtonState()">
            </td>
            <td class="cell">${escapeHtml(clientDisplay)}</td>
            <td class="cell">${escapeHtml(categoryDisplay)}</td>
            <td class="cell">${escapeHtml(torrentName)}</td>
            <td class="cell">${escapeHtml(folderDisplay)}</td>
          </tr>`;
      }).filter(r => r).join('');
      
      const footer = `
            </tbody>
          </table>
        </div>`;
      
      return header + body + footer;
    }

    function parseOrphanGroups(files) {
      const groups = {};
      const ungroupedFiles = [];
      
      for (const file of files) {
        // Check if this is enhanced format: client|torrent_id|torrent_name|category_or_label|tags|file_path
        if (file.includes('|')) {
          const parts = file.split('|');
          if (parts.length === 6) {
            const [client, torrentId, torrentName, label, tags, filePath] = parts;
            if (!groups[torrentName]) {
              groups[torrentName] = [];
            }
            groups[torrentName].push(filePath);
          } else {
            // Malformed enhanced format, treat as ungrouped
            ungroupedFiles.push(file);
          }
        } else {
          // True orphan - just a file path, group by folder
          const parts = file.split('/');
          let folderName = null;
          
          // Look for meaningful directory names (skip generic paths)  
          for (let i = parts.length - 1; i >= 0; i--) {
            const part = parts[i];
            if (part && part !== 'links' && part !== 'data' && part !== 'torrents' && 
                part !== 'deluge' && part !== 'qbit' && part !== 'music' && 
                part !== 'redacted' && part !== 'hawke-uno' && !part.startsWith('.')) {
              // If it's a file (has extension), use parent directory
              if (part.includes('.') && i > 0) {
                folderName = parts[i-1];
              } else {
                folderName = part;
              }
              break;
            }
          }
          
          if (folderName) {
            if (!groups[folderName]) {
              groups[folderName] = [];
            }
            groups[folderName].push(file);
          } else {
            ungroupedFiles.push(file);
          }
        }
      }
      
      // Only group folders with multiple files, single files become ungrouped
      const finalGroups = {};
      const finalUngrouped = [...ungroupedFiles];
      
      for (const [groupName, groupFiles] of Object.entries(groups)) {
        if (groupFiles.length > 1) {
          finalGroups[groupName] = groupFiles;
        } else {
          finalUngrouped.push(...groupFiles);
        }
      }
      
      // Add ungrouped files as individual items (no grouping)
      return { groups: finalGroups, ungrouped: finalUngrouped };
    }

    function renderOrphanGroups(result) {
      const groups = result.groups || {};
      const ungrouped = result.ungrouped || [];
      
      let html = "";
      
      // Render grouped files (folders with multiple files)
      const keys = Object.keys(groups).sort();
      for (const folderName of keys) {
          const files = groups[folderName] || [];
          const hasMany = files.length >= 10;
          
          
          const rows = files.map(r => {
            const checkboxCell = `<td class="cell checkbox"><input type="checkbox" class="file-checkbox" data-filepath="${escapeHtml(r)}" onchange="updateDeleteButtonState()"></td>`;
              
            return `
              <tr class="row">
                  ${checkboxCell}
                  <td class="cell path">
                    <span class="clickable-filename" data-filepath="${escapeHtml(r)}" data-type="filename" title="Click to see relationships">
                      ${escapeHtml(r)}
                    </span>
                  </td>
              </tr>`;
          }).join('');
          const isOpen = expandedTorrents.has(folderName);
          html += `
              <div class="torrent-hdr">
                  <span id="toggle-${escapeHtml(folderName)}" class="toggle-btn" onclick="toggleTorrent('${escapeHtml(folderName)}')">${isOpen ? "‚àí" : "+"}</span>
                  <h3 onclick="toggleTorrent('${escapeHtml(folderName)}')" style="cursor: pointer;">${escapeHtml(folderName)}</h3>
                  <span class="badge">Files <span class="pill">${files.length}</span></span>
                  <label class="select-all-label" onclick="event.stopPropagation();">
                    <input type="checkbox" class="select-all-checkbox" onchange="toggleFolderSelection('${escapeHtml(folderName)}')" />
                    Select All
                  </label>
              </div>
              <div id="files-${escapeHtml(folderName)}" class="torrent-files ${isOpen ? "open" : ""}">
                  <div class="table-wrap"><table class="grid"><tbody>${rows}</tbody></table></div>
              </div>`;
      }
      
      // Render ungrouped files (single files, no grouping)
      if (ungrouped.length > 0) {
        const ungroupedFiles = ungrouped;
        const ungroupedRows = ungroupedFiles.map(r => `
            <tr class="row">
                <td class="cell checkbox"><input type="checkbox" class="file-checkbox" data-filepath="${escapeHtml(r)}" onchange="updateDeleteButtonState()"></td>
                <td class="cell path">
                  <span class="clickable-filename" data-filepath="${escapeHtml(r)}" data-type="filename" title="Click to see relationships">
                    ${escapeHtml(r)}
                  </span>
                </td>
            </tr>`).join('');
        html += `<div class="table-wrap"><table class="grid"><tbody>${ungroupedRows}</tbody></table></div>`;
      }
      
      return html;
    }

    function renderCurrent(){
      const root = byId('section-body');
      if (!currentPayload) return;
      
      // If scan is in progress, clear content area (progress is shown in status bar)
      if (scanInProgress) {
        root.innerHTML = "";
        return;
      }
      
      const key = currentKey || "";
      let html = "";

      if (key.endsWith("orphans")) {
        const files = currentPayload.files || [];
        const clientName = key.startsWith("deluge") ? "Deluge" : "qBittorrent";
        const result = parseOrphanGroups(files);
        if (Object.keys(result.groups).length > 0 || result.ungrouped.length > 0) {
          html += `<div class="section-hdr"><h3>${clientName} Orphans ‚Äî Files</h3></div>`;
          html += renderOrphanGroups(result);
        } else {
          html += rowsToTable(`${clientName} Orphans ‚Äî Files`, files);
        }

      } else if (key.endsWith("runaways")) {
        const clientName = key.startsWith("deluge") ? "Deluge" : "qBittorrent";
        const groups = currentPayload.missing_by_torrent || {};
        const torrentInfo = currentPayload.torrent_info || {};
        if (Object.keys(groups).length > 0) {
          html += `<div class="section-hdr"><h3>${clientName} Runaways ‚Äî Missing on Disk</h3></div>`;
          html += renderRunaways(groups, torrentInfo);
        } else {
          const rows = currentPayload.missing || [];
          html += rowsToTable(`${clientName} Runaways ‚Äî Missing on Disk`, rows, 'torrent');
        }

      } else if (key.endsWith("reportcards")) {
        const rows = currentPayload.errors || [];
        const clientName = key.startsWith("deluge") ? "Deluge" : "qBittorrent";
        
        // Group by error message
        const grouped = {};
        rows.forEach(row => {
          // Parse the pipe-delimited format: client|torrent_id|torrent_name|category|tags|error_message
          const parts = row.split('|');
          if (parts.length >= 6) {
            const errorMessage = parts[5] || 'Unknown error';
            if (!grouped[errorMessage]) {
              grouped[errorMessage] = [];
            }
            grouped[errorMessage].push(row);
          }
        });
        
        // Render grouped report cards
        html += `<div class="panel">`;
        const errorCount = Object.keys(grouped).length;
        if (errorCount === 0) {
          html += `<h3>${clientName} Report Cards ‚Äî Tracker Errors</h3>`;
          html += `<div class="empty">No tracker errors found.</div>`;
        } else {
          html += `<h3>${clientName} Report Cards ‚Äî Tracker Errors (${errorCount} error types)</h3>`;
          
          // Sort error messages by frequency (most common first)
          const sortedErrors = Object.entries(grouped).sort((a, b) => b[1].length - a[1].length);
          
          for (const [errorMessage, errorRows] of sortedErrors) {
            const groupId = `error-${btoa(errorMessage).replace(/[^a-zA-Z0-9]/g, '')}`;
            const isExpanded = expandedGroups.has(groupId);
            const displayStyle = isExpanded ? 'block' : 'none';
            const buttonText = isExpanded ? '-' : '+';
            
            html += `
              <div class="section-hdr">
                <h3>${errorMessage} <span class="badge">${errorRows.length} torrent${errorRows.length > 1 ? 's' : ''}</span></h3>
                <button class="btn btn-xs" onclick="toggleGroup('${groupId}')">${buttonText}</button>
              </div>
              <div id="${groupId}" class="panel" style="display: ${displayStyle};">
                ${renderReportCardsTable(errorRows)}
              </div>
            `;
          }
        }
        html += `</div>`;
      } else {
        html = `<div class="empty">Unknown section.</div>`;
      }
      root.innerHTML = html || `<div class="empty">No rows to display.</div>`;
    }


    // Toggle expandable groups for report cards
    function toggleGroup(groupId) {
      const group = document.getElementById(groupId);
      const button = document.querySelector(`button[onclick="toggleGroup('${groupId}')"]`);
      if (group && button) {
        if (group.style.display === 'none') {
          group.style.display = 'block';
          button.textContent = '-';
          expandedGroups.add(groupId);
        } else {
          group.style.display = 'none';
          button.textContent = '+';
          expandedGroups.delete(groupId);
        }
      }
    }

    // File relationships modal functions
    async function showFileRelationships(filePath, type = 'filename') {
      const modal = byId('relationshipsModal');
      const loading = byId('modalLoading');
      const results = byId('modalResults');
      const title = byId('modalTitle');
      
      // Extract filename or torrent name from path
      let searchParam = '';
      let searchType = type;
      
      if (type === 'filename') {
        // Extract just the filename from the full path
        searchParam = filePath.split('/').pop();
        title.textContent = `Files matching: ${searchParam}`;
      } else if (type === 'torrent') {
        // Extract torrent name from runaway format "TorrentName | filepath"
        searchParam = filePath.split(' | ')[0];
        searchType = 'torrent_name';
        title.textContent = `Torrents matching: ${searchParam}`;
      }
      
      // Show modal and loading
      modal.style.display = 'block';
      loading.style.display = 'block';
      results.innerHTML = '';
      
      try {
        const params = new URLSearchParams();
        if (searchType === 'filename') {
          params.append('filename', searchParam);
        } else {
          params.append('torrent_name', searchParam);
        }
        
        const response = await fetch(`/api/file-relationships?${params}`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const relationships = await response.json();
        loading.style.display = 'none';
        
        if (relationships.length === 0) {
          results.innerHTML = '<p>No relationships found across torrent clients.</p>';
          return;
        }
        
        // First show the orphaned file
        const orphanPath = filePath; // This is the original clicked file path
        let html = `
          <div class="orphaned-section">
            <div class="orphan-line">
              <strong>Orphan:</strong> ${escapeHtml(orphanPath)}
            </div>
          </div>
        `;
        
        // Then show relationships if any found
        if (relationships.length > 0) {
          html += `
            <p style="margin: 16px 0 8px 0;"><strong>Found ${relationships.length} relationship(s):</strong></p>
            <table class="relationships-table">
              <thead>
                <tr>
                  <th>Client</th>
                  <th>Category/Label</th>
                  <th>Title</th>
                  <th>Tracker</th>
                  <th>Path/File Name</th>
                </tr>
              </thead>
              <tbody>
          `;
          
          for (const rel of relationships) {
            const client = rel.client.toUpperCase();
            const label = rel.label || 'None';
            const title = rel.match_title || rel.orphan_title || 'Unknown';
            const tracker = rel.tracker || 'Unknown';
            
            // For each relationship, show the full matching file path
            let pathDisplay = rel.matching_file || rel.save_path || rel.torrent_name;
            
            html += `
              <tr>
                <td class="client-cell">${client}</td>
                <td class="label-cell">${escapeHtml(label)}</td>
                <td class="title-cell">${escapeHtml(title)}</td>
                <td class="tracker-cell">${escapeHtml(tracker)}</td>
                <td class="path-cell">${escapeHtml(pathDisplay)}</td>
              </tr>
            `;
          }
          
          html += `
              </tbody>
            </table>
          `;
        }
        
        html += '</div>';
        loading.style.display = 'none';
        results.innerHTML = html;
        
        // Note: Delete functionality is now handled via checkboxes in the main list
        
      } catch (error) {
        loading.style.display = 'none';
        results.innerHTML = `<p style="color: red;">Error: ${escapeHtml(error.message)}</p>`;
      }
    }
    
    function closeRelationshipsModal() {
      byId('relationshipsModal').style.display = 'none';
    }
    
    // Removed currentDeleteFilePath - using bulk delete only now
    
    // Removed showDeleteSection - using bulk delete only now

    // Bulk delete functionality
    function updateDeleteButtonState() {
      const fileCheckboxes = document.querySelectorAll('.file-checkbox:checked');
      const torrentCheckboxes = document.querySelectorAll('.torrent-checkbox:checked');
      const deleteBtn = byId('deleteSelectedBtn');
      const countSpan = byId('selectedCount');
      
      // Safety check in case elements don't exist (e.g., after page refresh)
      if (!deleteBtn) return;
      
      const fileCount = fileCheckboxes.length;
      const torrentCount = torrentCheckboxes.length;
      const totalCount = fileCount + torrentCount;
      
      // Update button text based on selection type and recreate the count span
      if (torrentCount > 0 && fileCount === 0) {
        deleteBtn.innerHTML = `Delete ${torrentCount} Torrent${torrentCount > 1 ? 's' : ''} (<span id="selectedCount">${totalCount}</span>)`;
      } else if (fileCount > 0 && torrentCount === 0) {
        deleteBtn.innerHTML = `Delete ${fileCount} File${fileCount > 1 ? 's' : ''} (<span id="selectedCount">${totalCount}</span>)`;
      } else if (totalCount > 0) {
        deleteBtn.innerHTML = `Delete ${totalCount} Item${totalCount > 1 ? 's' : ''} (<span id="selectedCount">${totalCount}</span>)`;
      }
      
      if (totalCount > 0) {
        deleteBtn.style.display = 'inline-block';
      } else {
        deleteBtn.style.display = 'none';
      }
    }

    function getSelectedFiles() {
      const checkboxes = document.querySelectorAll('.file-checkbox:checked');
      return Array.from(checkboxes).map(cb => cb.dataset.filepath);
    }

    function getSelectedTorrents() {
      const checkboxes = document.querySelectorAll('.torrent-checkbox:checked');
      return Array.from(checkboxes).map(cb => cb.dataset.torrent);
    }

    function toggleFolderSelection(folderName) {
      const selectAllCheckbox = document.querySelector(`.select-all-checkbox[onchange*="${folderName}"]`);
      const folderDiv = document.getElementById(`files-${folderName}`);
      
      if (!folderDiv || !selectAllCheckbox) return;
      
      const fileCheckboxes = folderDiv.querySelectorAll('.file-checkbox');
      const isSelectingAll = selectAllCheckbox.checked;
      
      // Set all file checkboxes to match the select-all checkbox
      fileCheckboxes.forEach(checkbox => {
        checkbox.checked = isSelectingAll;
      });
      
      // Update the delete button state
      updateDeleteButtonState();
    }

    async function deleteSelectedFiles() {
      const selectedFiles = getSelectedFiles();
      const selectedTorrents = getSelectedTorrents();
      const totalItems = selectedFiles.length + selectedTorrents.length;
      
      if (totalItems === 0) return;
      
      // Update modal content based on selection type
      const deleteMessage = byId('deleteMessage');
      const deleteItemCount = byId('deleteItemCount');
      const confirmBtn = byId('confirmDeleteBtn');
      
      deleteItemCount.textContent = totalItems;
      
      if (selectedTorrents.length > 0 && selectedFiles.length === 0) {
        deleteMessage.innerHTML = `This will <strong>permanently remove</strong> <span id="deleteItemCount">${selectedTorrents.length}</span> selected torrents and their files from the torrent client.`;
        confirmBtn.textContent = 'Remove Torrents';
        // Hide file-specific sections for torrent deletion
        byId('folderDeleteSection').style.display = 'none';
        byId('deleteFolderCheckbox').style.display = 'none';
        populateTorrentsList(selectedTorrents);
      } else if (selectedFiles.length > 0 && selectedTorrents.length === 0) {
        deleteMessage.innerHTML = `This will <strong>permanently delete</strong> <span id="deleteItemCount">${selectedFiles.length}</span> selected files from your filesystem.`;
        confirmBtn.textContent = 'Delete Files Permanently';
        
        // Populate file list and check for folder deletion opportunity
        populateFilesList(selectedFiles);
        await checkForFolderDeletion(selectedFiles);
      } else {
        deleteMessage.innerHTML = `This will <strong>permanently delete/remove</strong> <span id="deleteItemCount">${totalItems}</span> selected items.`;
        confirmBtn.textContent = 'Delete Items Permanently';
        // Hide file-specific sections for mixed deletion
        byId('folderDeleteSection').style.display = 'none';
        byId('deleteFolderCheckbox').style.display = 'none';
        // Show both files and torrents in mixed mode
        populateMixedList(selectedFiles, selectedTorrents);
      }
      
      byId('bulkDeleteModal').style.display = 'block';
    }

    function closeBulkDeleteModal() {
      byId('bulkDeleteModal').style.display = 'none';
      // Reset folder deletion state
      byId('folderDeleteSection').style.display = 'none';
      byId('deleteFolderCheckbox').style.display = 'none';
      byId('deleteFolderOption').checked = false;
    }

    function populateFilesList(selectedFiles) {
      const filesList = byId('filesList');
      
      if (selectedFiles.length === 0) {
        filesList.innerHTML = '<p style="color: var(--muted); font-style: italic;">No files selected.</p>';
        return;
      }
      
      let html = '';
      selectedFiles.forEach((filePath, index) => {
        const fileName = filePath.split('/').pop();
        html += `
          <div style="margin: 8px 0; padding: 8px; background: var(--bg); border-radius: 3px; border-left: 3px solid #dc3545; border: 1px solid var(--border);">
            <div style="font-weight: bold; color: #dc3545; margin-bottom: 3px;">${escapeHtml(fileName)}</div>
            <div style="font-size: 12px; color: var(--muted); font-family: monospace; word-break: break-all;">${escapeHtml(filePath)}</div>
          </div>
        `;
      });
      
      filesList.innerHTML = html;
    }
    
    function populateTorrentsList(selectedTorrents) {
      const filesList = byId('filesList');
      
      if (selectedTorrents.length === 0) {
        filesList.innerHTML = '<p style="color: var(--muted); font-style: italic;">No torrents selected.</p>';
        return;
      }
      
      let html = '';
      selectedTorrents.forEach((torrentData, index) => {
        // Parse pipe-delimited format: client|torrent_id|torrent_name|category|tags|error_message|folder_path
        const parts = torrentData.split('|');
        if (parts.length >= 3) {
          const torrentName = parts[2] || 'Unknown torrent';
          const category = parts[3] || 'No category';
          const errorMsg = parts[5] || 'No error';
          
          html += `
            <div style="margin: 8px 0; padding: 8px; background: var(--bg); border-radius: 3px; border-left: 3px solid #dc3545; border: 1px solid var(--border);">
              <div style="font-weight: bold; color: #dc3545; margin-bottom: 3px;">${escapeHtml(torrentName)}</div>
              <div style="font-size: 12px; color: var(--muted); margin-bottom: 3px;">Category: ${escapeHtml(category)}</div>
              <div style="font-size: 12px; color: var(--muted); font-family: monospace;">${escapeHtml(errorMsg)}</div>
            </div>
          `;
        }
      });
      
      filesList.innerHTML = html;
    }
    
    function populateMixedList(selectedFiles, selectedTorrents) {
      const filesList = byId('filesList');
      let html = '';
      
      // Add files
      if (selectedFiles.length > 0) {
        html += '<h4 style="margin: 0 0 10px 0; color: var(--text);">Files to be deleted:</h4>';
        selectedFiles.forEach((filePath, index) => {
          const fileName = filePath.split('/').pop();
          html += `
            <div style="margin: 8px 0; padding: 8px; background: var(--bg); border-radius: 3px; border-left: 3px solid #dc3545; border: 1px solid var(--border);">
              <div style="font-weight: bold; color: #dc3545; margin-bottom: 3px;">${escapeHtml(fileName)}</div>
              <div style="font-size: 12px; color: var(--muted); font-family: monospace; word-break: break-all;">${escapeHtml(filePath)}</div>
            </div>
          `;
        });
      }
      
      // Add torrents
      if (selectedTorrents.length > 0) {
        if (selectedFiles.length > 0) {
          html += '<hr style="margin: 15px 0; border: 1px solid var(--border);">';
        }
        html += '<h4 style="margin: 0 0 10px 0; color: var(--text);">Torrents to be removed:</h4>';
        selectedTorrents.forEach((torrentData, index) => {
          const parts = torrentData.split('|');
          if (parts.length >= 3) {
            const torrentName = parts[2] || 'Unknown torrent';
            const category = parts[3] || 'No category';
            const errorMsg = parts[5] || 'No error';
            
            html += `
              <div style="margin: 8px 0; padding: 8px; background: var(--bg); border-radius: 3px; border-left: 3px solid #dc3545; border: 1px solid var(--border);">
                <div style="font-weight: bold; color: #dc3545; margin-bottom: 3px;">${escapeHtml(torrentName)}</div>
                <div style="font-size: 12px; color: var(--muted); margin-bottom: 3px;">Category: ${escapeHtml(category)}</div>
                <div style="font-size: 12px; color: var(--muted); font-family: monospace;">${escapeHtml(errorMsg)}</div>
              </div>
            `;
          }
        });
      }
      
      if (html === '') {
        html = '<p style="color: var(--muted); font-style: italic;">No items selected.</p>';
      }
      
      filesList.innerHTML = html;
    }

    async function checkForFolderDeletion(selectedFiles) {
      if (selectedFiles.length === 0) return;
      
      try {
        // Group files by their parent directories
        const dirFiles = {};
        selectedFiles.forEach(filePath => {
          const parentDir = filePath.substring(0, filePath.lastIndexOf('/'));
          if (!dirFiles[parentDir]) {
            dirFiles[parentDir] = [];
          }
          dirFiles[parentDir].push(filePath);
        });
        
        // Find directories where all files are selected
        for (const [parentDir, filesInDir] of Object.entries(dirFiles)) {
          try {
            // Check if all files in this directory are selected
            const response = await fetch(`/api/check-folder-files`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ folder_path: parentDir, selected_files: filesInDir })
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.can_delete_folder && result.total_files === filesInDir.length) {
                // Show folder deletion option
                showFolderDeletionOption(parentDir, result.total_files);
                break; // Only show for first eligible folder
              }
            }
          } catch (error) {
            console.warn('Error checking folder:', parentDir, error);
          }
        }
      } catch (error) {
        console.error('Error in checkForFolderDeletion:', error);
      }
    }

    function showFolderDeletionOption(folderPath, fileCount) {
      const folderName = folderPath.split('/').pop();
      
      // Update folder section
      byId('folderDeleteMessage').textContent = `All ${fileCount} files in this folder are selected. You can delete the entire folder instead:`;
      byId('folderPath').textContent = folderPath;
      byId('folderDeleteSection').style.display = 'block';
      
      // Update checkbox
      byId('deleteFolderLabel').textContent = `Delete Folder "${folderName}"`;
      byId('deleteFolderCheckbox').style.display = 'flex';
      
      // Store folder path for later use
      byId('deleteFolderOption').setAttribute('data-folder-path', folderPath);
    }

    // Make bulk delete modal draggable
    function makeDraggable() {
      const modal = document.querySelector('.draggable-modal');
      const header = document.querySelector('.draggable-header');
      
      if (!modal || !header) return;
      
      let isDragging = false;
      let startX, startY, startLeft, startTop;
      
      header.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        
        const rect = modal.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;
        
        modal.style.transform = 'none';
        modal.style.left = startLeft + 'px';
        modal.style.top = startTop + 'px';
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        e.preventDefault();
      });
      
      function onMouseMove(e) {
        if (!isDragging) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        modal.style.left = (startLeft + dx) + 'px';
        modal.style.top = (startTop + dy) + 'px';
      }
      
      function onMouseUp() {
        isDragging = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      }
    }

    async function confirmBulkDelete() {
      const selectedFiles = getSelectedFiles();
      const selectedTorrents = getSelectedTorrents();
      
      // Check if folder deletion is requested
      const deleteFolderOption = byId('deleteFolderOption');
      const shouldDeleteFolder = deleteFolderOption.checked;
      const folderPath = deleteFolderOption.getAttribute('data-folder-path');
      
      closeBulkDeleteModal();
      
      // Show loading state
      const deleteBtn = byId('deleteSelectedBtn');
      const originalText = deleteBtn.innerHTML;
      deleteBtn.innerHTML = 'Deleting...';
      deleteBtn.disabled = true;
      
      try {
        let response, result;
        let deletedFolders = 0;
        
        // Handle torrent deletion
        if (selectedTorrents.length > 0) {
          response = await fetch('/api/bulk-delete-torrents', {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ torrents: selectedTorrents })
          });
          result = await response.json();
        }
        // Handle file deletion (with optional folder deletion)  
        else if (selectedFiles.length > 0) {
          if (shouldDeleteFolder && folderPath) {
            // Delete the entire folder
            response = await fetch('/api/delete-folder', {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ folder_path: folderPath })
            });
            
            if (response.ok) {
              result = await response.json();
              deletedFolders = 1;
              
              // Create custom result format to match file deletion response
              result = {
                success: true,
                deleted_count: selectedFiles.length,
                failed_count: 0,
                deleted_folder_count: deletedFolders,
                message: `Deleted folder and ${selectedFiles.length} files inside`
              };
            } else {
              result = await response.json();
            }
          } else {
            // Delete individual files
            response = await fetch('/api/bulk-delete-orphan-files', {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ file_paths: selectedFiles })
            });
            result = await response.json();
          }
        }
        else {
          throw new Error('No files or torrents selected');
        }
        
        if (response.ok) {
          // Show success message with details
          let successMsg = '';
          if (selectedTorrents.length > 0) {
            successMsg = `Successfully removed ${result.deleted_count || result.success_count || selectedTorrents.length} torrents.`;
            if (result.failed_count > 0) {
              successMsg += `\nFailed to remove ${result.failed_count} torrents.`;
            }
          } else {
            successMsg = `Successfully deleted ${result.deleted_count} files.`;
            if (result.deleted_folder_count > 0) {
              successMsg += `\nDeleted ${result.deleted_folder_count} empty folders.`;
            }
            if (result.failed_count > 0) {
              successMsg += `\nFailed to delete ${result.failed_count} files.`;
            }
          }
          
          // Simple success notification 
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000;
            background: #4CAF50; color: white; padding: 20px 30px;
            border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center; font-size: 16px;
          `;
          notification.textContent = successMsg;
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 4000);
          
          // Refresh the current section to update the display
          if (currentKey) {
            loadSection(currentKey, true);
          }
          
          // Update sidebar counts after deletion
          updateHighlightsAfterScan();
          
          // If we deleted torrents, also refresh report cards to remove deleted torrents
          if (selectedTorrents.length > 0) {
            // Force refresh report cards data by clearing cache and reloading
            await refreshReportCards();
          }
        } else {
          // Simple error notification
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000;
            background: #f44336; color: white; padding: 20px 30px;
            border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center; font-size: 16px;
          `;
          notification.textContent = `Failed to delete files: ${result.detail || 'Unknown error'}`;
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 4000);
        }
      } catch (error) {
        // Simple error notification
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000;
          background: #f44336; color: white; padding: 20px 30px;
          border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
          text-align: center; font-size: 16px;
        `;
        notification.textContent = `Error deleting files: ${error.message}`;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 4000);
      } finally {
        // Reset button state
        deleteBtn.innerHTML = originalText;
        deleteBtn.disabled = false;
        // Note: Don't call updateDeleteButtonState() here since page refreshes anyway
      }
    }
    
    // executeDeleteFile removed - using bulk delete only now
    
    // Runaway relationship functions removed - now displayed directly in tree view
    
    // Config modal functions
    async function openConfigModal() {
      const modal = byId('configModal');
      
      try {
        // Load current config
        const response = await fetch('/api/config-full');
        if (response.ok) {
          const config = await response.json();
          populateConfigForm(config);
        } else {
          // If config endpoint doesn't exist, get from existing config
          const existingConfig = cfg || {};
          populateConfigFormFromExisting(existingConfig);
        }
        
        modal.style.display = 'block';
      } catch (error) {
        console.error('Error loading config:', error);
        modal.style.display = 'block';
      }
    }
    
    function populateConfigForm(config) {
      // Client enables
      byId('enableDeluge').checked = config.Enable_Deluge || false;
      byId('enableQbit').checked = config.Enable_Qbit || false;
      
      // Deluge settings
      byId('delugeUrl').value = config.Deluge_Url || '';
      byId('delugePass').value = config.Deluge_Pass || '';
      byId('delugeTorrentFolder').value = config.Deluge_Torrent_Folder || '';
      byId('delugePathIn').value = config.Deluge_Path_In || '';
      byId('delugePathOut').value = config.Deluge_Path_Out || '';
      
      // qBittorrent settings
      byId('qbitUrl').value = config.Qbit_Url || '';
      byId('qbitUser').value = config.Qbit_User || '';
      byId('qbitPass').value = config.Qbit_Pass || '';
      byId('qbitTorrentFolder').value = config.Qbit_Torrent_Folder || '';
      byId('qbitPathIn').value = config.Qbit_Path_In || '';
      byId('qbitPathOut').value = config.Qbit_Path_Out || '';
      
      // Logging
      byId('logLevel').value = config.Log_Level || 'INFO';
    }
    
    function populateConfigFormFromExisting(config) {
      // Fallback if full config endpoint doesn't exist
      byId('enableDeluge').checked = config.ENABLE_DELUGE || false;
      byId('enableQbit').checked = config.ENABLE_QBIT || false;
      // Leave other fields empty for user to fill
    }
    
    async function saveConfig() {
      const configData = {
        Enable_Deluge: byId('enableDeluge').checked,
        Enable_Qbit: byId('enableQbit').checked,
        
        Deluge_Url: byId('delugeUrl').value.trim(),
        Deluge_Pass: byId('delugePass').value.trim(),
        Deluge_Torrent_Folder: byId('delugeTorrentFolder').value.trim(),
        Deluge_Path_In: byId('delugePathIn').value.trim(),
        Deluge_Path_Out: byId('delugePathOut').value.trim(),
        
        Qbit_Url: byId('qbitUrl').value.trim(),
        Qbit_User: byId('qbitUser').value.trim(),
        Qbit_Pass: byId('qbitPass').value.trim(),
        Qbit_Torrent_Folder: byId('qbitTorrentFolder').value.trim(),
        Qbit_Path_In: byId('qbitPathIn').value.trim(),
        Qbit_Path_Out: byId('qbitPathOut').value.trim(),
        
        Log_Level: byId('logLevel').value
      };
      
      try {
        const response = await fetch('/api/config', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(configData)
        });
        
        if (response.ok) {
          closeConfigModal();
          // Reload config to update UI
          await initConfig();
        } else {
          const error = await response.text();
          console.error(`Error saving configuration: ${error}`);
        }
      } catch (error) {
        console.error(`Error saving configuration: ${error.message}`);
      }
    }
    
    function closeConfigModal() {
      byId('configModal').style.display = 'none';
    }
    
    function toggleHelp() {
      const helpSection = byId('helpSection');
      if (helpSection.style.display === 'none') {
        helpSection.style.display = 'block';
      } else {
        helpSection.style.display = 'none';
      }
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
      const relationshipsModal = byId('relationshipsModal');
      const configModal = byId('configModal');
      const bulkDeleteModal = byId('bulkDeleteModal');
      
      if (event.target === relationshipsModal) {
        closeRelationshipsModal();
      } else if (event.target === configModal) {
        closeConfigModal();
      } else if (event.target === bulkDeleteModal) {
        closeBulkDeleteModal();
      }
    }

    window.addEventListener('DOMContentLoaded', async () => {
      await initConfig();
      
      // Initialize draggable functionality
      makeDraggable();
      
      // Event delegation for clickable filenames (fixes issues with special characters)
      document.addEventListener('click', function(event) {
        if (event.target.classList.contains('clickable-filename')) {
          const filePath = event.target.getAttribute('data-filepath');
          const type = event.target.getAttribute('data-type') || 'filename';
          if (filePath) {
            showFileRelationships(filePath, type);
          }
        }
      });
      
      // Allow DOM to fully render before showing to prevent layout shifts
      setTimeout(() => {
        document.body.classList.add('loaded');
      }, 50);
      
      // Clear any hash to start fresh on main page
      if (window.location.hash) {
        history.replaceState(null, null, window.location.pathname);
      }
      
      // Start on main page - don't auto-load any sections
      // User can click sidebar links to navigate to specific sections
      
      (function scheduleNext(ms){ setTimeout(function tick(){ pollStatusOnce(); scheduleNext(3500); }, ms || 0); })(0);
    });
  </script>
</body>
</html>
